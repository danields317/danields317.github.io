# Internals
At its core Git is a map of keys and values. Each entry in the map is an object in the repository (files, folders, commits, more). The key is generated by hashing the content, the value is the content itself. Git stores each object in .git/objects by creating files named by the keys.
## Objects
Git stores a project by creating different types of objects. Each object is a different file. The content of the file depends on the type of object it is. Git also adds some header information inside of the object (file). The header adds metadata about the object (type, size, etc.).

Files are named by hashing (SHA-1) the information (and header) that the object consists of. The file gets stored in a subdirectory in the .git/objects folder. The subdirectory is named with the first 2 characters of the SHA-1, and the filename is the remaining 38 characters.
### Blobs
Blobs are the objects for storing files. A blob holds the file data hashed through SHA-1. Because the name of the object file is created by hashing the content, the name of the file is lost in a blob. These names are stored in tree objects.
```
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
```
### Trees
Tree objects are used to represent folders. A tree object hold the hashes of the files and other trees in the current tree object. The tree also holds the names of the files and folders of the objects.
```
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README
100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib
```
### Commits
A commit object holds a reference to a tree object. This tree is the source of the project. This results in a commit having a reference to the entire state of a project.
```
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700
First commit
```
Except for the first commit, all commits also contain a parent. This parent points to the commit that was made before the current one.

![Git](/img/git/objects-overview.png)
### Object versions
When a file in the project changes, Git will create a new object for it.
When a new commit is made, something will have changed so a commit always has a new tree to point to. This tree can then point to the new object, but can also point to already existing object for the object that didn't change since the last commit.

![Git](/img/git/commits-overview.png)
## Branches
A branch is also an object inside of Git. The branch object contains the hash of the latest commit on the branch. The branches are found the in .git/refs folder. The HEAD file in .git contains a reference to the current branch.

The HEAD describes what is being shown in the working directory, moving the HEAD changes the working directory content. E.g. switching branches means pointing the head to a different branch, which points to a commit, which loads a tree.

HEAD is a reference to a branch.

Branch then points to commit, commit to tree, etc.
### Tags
Tags are used to mark specific commits with additional information. E.g. a tag can be created to mark a specific commit as the release version or alpha version, etc.
Tags themselves are just like branches, they are objects that point to a specific commit. The difference is that this commit will never change.
There are two types of tags.

**Lightweight tags**
Lightweight tags have a name. Lightweight tags are just files with the tag as the file name and they hold a reference to a commit.
`git tag Release`

**Annotated tags**
Annotated tags give the ability to add a description about the tag (e.g. information about what the release contains). Annotated tags are objects. The tag name is the file name. The file holds the tag description and a reference to the commit.
`git tag Release:2 -a -m "Added a GUI"`

:::info
Tags are not automatically pushed to a remote when running `git push`. To push the tag object (and the commit it points to), run `git push origin tag [tag-name]`.
:::

## Merges
When merging a branch into another, changes are added to the current branch. Sometimes, there are conflicts and these need to be resolved. When this is done, a new commit must be created which commits the project after the merge was completed. A merge commit has two parents, the current commit and the commit that was merged from the other branch.

![Merging](/img/git/merge-overview.png)
## History
References between commits manage history of the project. References between commit and tree (and blobs/subtrees) manage content.
## Fast-forward
When one branch is merged into the other (e.g. ideas into main), it contains the code of the combined branches. When flipping this around (main into ideas), a commit already exists since the other merge already contains all data. Git can then do a fast-forward. Instead of creating a new commit, it just makes the other branch point to the same commit.

![Merging](/img/git/fast-forward-overview.png)
## Detached HEAD
Normally HEAD points to a branch, but it is also possible to make it point to a specific commit. Creating new commits when pointing to a commit results in the commit not being on a branch. It is possible to create a new branch when HEAD is on a commit, this will add the commit to the branch.

Commits that are not on branch are unreachable when leaving the commit (except when using the specific commit hash). When Git performs its automatic garbage collection, unreachable commits will be deleted.
`git checkout <commit-hash>`

## Rebasing
Rebasing is another way to combine the data of two branches. When rebasing, all new commits of the currently active branch are placed on top of the selected branch. Each commit is merged one by one. Under the hood, Git copies the commit and creates a new one to add to the commit. The original commits can then be garbage collected.

Rebasing happens commit by commit. With each commit, a merge conflict can arise. The rebasing process turns interactive at this point. The merge conflict has to be resolved. Then the rebasing can continue to the next commit until all commits have been added.

Rebasing changes project history since created branches are gone and new commits are made as copies of the real ones. This makes it look like the timeline was different.
`git rebase <base-branch>`

![Rebase](/img/git/rebase-overview.png)