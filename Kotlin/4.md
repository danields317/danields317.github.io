# Kotlin Functional Programming
This document contains a summary of functional programming features available in Kotlin.

## Lambdas
Lambdas are anonymous functions with a shorter syntax. The last statement of a lambda function is also what it will return.
When a lambda is used as the only or last argument in a function (e.g. in `map()`) the `()` can be omitted and the lambda can be placed directly after the function name. When a function takes a lambda as argument, the lambda needs to follow the pattern of amount of arguments and return type specified by the function.
```kotlin
{ one: Int, two: Int -> one + two }
{ println("HI") } // Lambdas without arguments don't need the arrow
values.map { it + 1 }

// Lambdas can be stored in variables
val resusable = {e: Int -> e + e}
values.map(reusable)
```

Kotlin lambdas are statically scoped and can interact with the environment they are created in. The example below shows that a lambda function is made in class One and a reference to the lambda is given to class Two. Even when executing it through class Two it can update number in class One.
```kotlin
class One {
    var number = 5
    val adder = { number += 1 }
}

// Require a value called 'f' of type Lambda without arguments returning a unit
class Two(val f: () -> Unit) {
    
}

fun main() {
    val one = One()
    println(one.number)
    one.adder()
    println(one.number)
    val two = Two(one.adder)
    two.f()
    println(one.number)
}
```

## Operations on Collections
Kotlin offers a bunch of functions on collection objects (e.g. lists, maps, etc.) to 