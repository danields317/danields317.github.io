# Kotlin Advanced Object Oriented Programming
This document contains a summary of advanced Object Oriented Programming features and concepts in Kotlin.

## Interfaces
An interface is defined with `interface` keyword. Any class implementing an interface has to mark each overridden function or variable with `override`.
Interfaces can also be used in `enum` classes. Then each `enum` value can define their own implementation for the interface value. 

```kotlin
interface Sound {
	fun makeSound(): String
}

class Microphone : Sound {
	override fun makeSound(): String {
		return "Singing!"
	}
}
```

### SAM Conversions
Single Abstract Method is an approach to interfaces where the interface only has one method. In Kotlin this can be explicitly defined through `fun interface`. Kotlin will then enforce this rule of only having one function.
It is also possible to instantiate SAM interfaces by passing a lambda to the interface. This will return an object with the method implement through the lambda.

```kotlin
fun interface Adder {
	fun add(one: Int, two: Int): Int
}

class Calculator: Adder {
	override fun add(one: Int, two: Int) {
		return one + two
	}
}
val lambda = Adder {one, two -> one + two}
lambda.add(1, 2)
```

## Complex Constructors
For additional code to run during object construction, Kotlin uses `init` blocks.
```kotlin
class Message(text: String) {
	// A property can still be val when initialized through init!
	private val content: String
	init {
		content = "Hi $text"
	}
}
```

## Secondary Constructors
When a class requires multiple different constructors, Kotlin offers the `constructor` block. The first statement in a secondary constructor must be to call another constructor until the main constructor has been called. This is needed because properties can be initialised directly in the main constructor and additional logic might depend on this. The other constructors are called with the `: this()` syntax behind the `constructor` method name.

```kotlin
class WithSecondary(i: Int) { 
	init { 
		trace("Primary: $i") 
	} 
	
	constructor(c: Int, d, Int) : this(c + d) { 
		trace("Secondary: '$c'") 
	}
```

## Inheritance
To inherit from a regular class, Kotlin uses similar syntax to interfaces but requires `()` to be added after the class. For a class and its members to be used for inheritance they also have to be marked as `open`.  To call the base class methods, the `super` keyword can be used.

```kotlin
open class Ape {
	open fun eatBanana() {println("Yummy")}
	open fun makeSound() {println("OOH AAH AAH")}
}

class Human: Ape() {
	override fun makeSound() {println("I hate doing taxes")}
	override fun eatBanana() {
		println("Let me peel the banana first")
		super.eatBanana()
	}
}
```

## Base Class Initialisation
When a base class expects values in its constructor, the derived class must deliver these values. Kotlin calls the constructor of the base class first and then goes down the inheritance chain. This way, values from the base class are available during initialisation of the derived classes.
```kotlin
open class SuperClass1(val i: Int) 
class SubClass1(i: Int) : SuperClass1(i)
```

## Abstract classes
